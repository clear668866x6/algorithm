function<int (int, int)>qor = [&] (int l, int r) {
    if (l == r)return l;
    return (int)(l | ((1ll << (__lg (l ^ r)) + 1) - 1));
    };


function<int (int, int)>qand = [&] (int l, int r) {
    if (l == r)return l;
    return (int)(l & ((1ll << (__lg (l ^ r)) + 1) - 1));
    };

/*
快速或
刚才题目思路已经讲了，就是把第一个不相同的后面的都变成 1，同时，也可以 O(1) 的计算，先构造一个长度为 l 异或 r 加一 的二进制数，只有第一位是 1，其他为 0，也就是 2
l⊕r+1
 ，因为 l 异或 r 的最高位一定是第一位不同的二进制位。然后减 1 一定是长度为 l⊕r 的二进制数，每一位都是一，然后用它与 l 按位或。

快速与
显然，结果一定是 l 与 r 相同的部分加一串 0，因为后面的部分一定会被若干个数清零。

与上面一样，最后用 l 与它做按位与即可，这样就可以清零后面的位了。

快速异或
打表找规律比较简单，由于篇幅不够直接写结论了，想知道证明过程可以去百度。

求 1,2,3...x 的异或和，跟 xmod4 的结果有关。具体如下：

xmod4=0，结果为 x。
xmod4=1，结果为 1。
xmod4=2，结果为 x+1。
xmod4=3，结果为 0。

*/