1. 当1e18不行的时候，用numeric_limits<int>::max()
2. 以后出现 x=1(mod n) 此时就得知道x和n互为质数，如果一个乘积是跟n互为质数，说明n要跟乘积的每个数互为质数(CF1514C)，
还有就是互为质数的数乘起来的乘积仍互为质数。也就是以后出现形如：x=1(mod n)，此时就考虑gcd.
3. bit_width(unsigned(x))求的是二进制的宽度