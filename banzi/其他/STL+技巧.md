1. 当1e18不行的时候，用numeric_limits<int>::max()
2. 以后出现 x=1(mod n) 此时就得知道x和n互为质数，如果一个乘积是跟n互为质数，说明n要跟乘积的每个数互为质数(CF1514C)，
还有就是互为质数的数乘起来的乘积仍互为质数。也就是以后出现形如：x=1(mod n)，此时就考虑gcd.
3. bit_width(unsigned(x))求的是二进制的宽度
4. 前缀和既可以过程性考虑也可以结果性考虑（如果前缀和有一直在改变的时候我们就考虑过程性）。
5. 对于同时要进行左端点排序和右端点排序，这几乎不可能，因此就要对l+r进行排序。
6. 