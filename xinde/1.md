## 体会

1. 发现 `codeforces` 的 edu 很多跟abc都是板题。
2. `multiset` 是基于红黑树实现的，它的时间复杂度：
```
插入操作：O(log n)
查找操作：O(log n)
删除操作：O(log n)
```
3. multiset 可以加入优先级，即 `multiset<PII>`。
4. multiset 删除最后一个元素必须要 --s.end()，删除第一个元素就不需要了
5. 数位dp：一般的bool有两个，一个是到达边界一个是到达0。然后看情况新增变量。
6. 有自环情况下，拓扑序无法处理，此时要求循环节就必须用暴力的方式。
7. 以后如果简单题想复杂就不要继续往这方面想，想问题得用多个角度来做。
8. 当需要排序的内容与两个变量有关的情况下，我们可以考虑相加（此时也叫做邻项交换法）
9. 如果 $a_i=\max(b_i,b_{i+1})，a_{i-1}=\max(b_{i-1},b_i)$ 的时候，那么 $b_i\le \min(a_i,a_{i-1})$。 
10. 有要求什么约数的时候，埃氏筛的思想很重要，就是把它的倍数都标记了的思想。
11. 很多情况下，如果求双重循环，此时可以考虑把这个数组排序完再算。
12. 如果把一个数分解成 $(r-l+1)(l+r)=n$ 的形式，此时就得考虑枚举因数了。
13. 算排名最好用`upper_bound`，要不然会有问题的。
14. 有时候题目很像差分，但数据规模很大，那么我们可以用 `map` 来维护，或者通过类似：`w[++cnt]={l,1},w[++cnt]={l+r,-1}` 的操作，然后通过画图可以去分析它们的性质（据说可能还会有单调性，比如abc221d）。
15. 有的时候得注意精度啊，服了啊，刚刚没有开 __int128 就爆炸了。
16. 题目长的时候得认真看呐，要不然会出问题啊。
17. 多项式乘法除法可以采用大除法。
多项式大除法：
```
void solve() {
    cin>>n>>m;

    FOR(i,0,n)cin>>a[i];
    FOR(i,0,n+m)cin>>c[i];

    FORD(i,0,m){
        b[i]=c[i+n]/a[n];
        FOR(j,0,n){
            c[i+j]-=b[i]*a[j];
        }
    }

    FOR(i,0,m)cout<<b[i]<<" ";
}
```
18. 有时候数据范围小的可能是贪心呐，不要总是想着dfs。
19. 树上两点必然存在简单路径，因此要求两个点间的路径，直接以一个端点为根节点来做就行。
20. 有的时候二分不行的时候（就是想的很复杂的时候），我们可以考虑一下枚举答案。
21. 当出现两个变量的时候，我们尝试去只枚举一个变量，这样就可以看成一层一层的来了。
22. 当大数的时候要算末尾什么0的个数，本质上就是 $2^x\times 5^y$，如果是阶乘的话，$2$ 的因子最多。因为每连续的偶数就有，因此只需要看5的个数。
23. 注意有的时候bfs和dfs的时间复杂度是 $O(2n)$ 的有的时候。
24. 位运算偶尔可以用到字典树，它可以用来算最大异或和。
25. cses1629 选择不相交的区间问题。
26. 有的时候菊花图很有性质啊。
27. 比如cf1893A这道题，如果题目引进了一个全新的概念，此时我们就得去发现全新的概念的性质：比如这道题是移动发现不动点总是在每次移动的最后一个位置。（刚开始想错了，一直想着它跟下标的关系，然后发现找不出任何有关的性质）。
28. gcd(a,b)=gcd(b-a,b)
29. 对于一个集合，要求最小的某个数不能被表示出来。那么就先排序，然后如果前i-1个数能被表示出来，那么它一定能表示出1，所以对于第i个数，肯定能表示出 a_i+1，那么如果我们假设x个数能被表示出来，很容易证明 a_i+x也是能被表示。 那么结论很明显就是 a_i<=x
30. 树状数组优化的最长上升子序列问题的query(w[i]-1)，这里的-1就是保证它是严格的上升。
31. CF1967A [好的讲解](https://zhuanlan.zhihu.com/p/708160419)
32. 如果要算不重叠的 $s_r=s_{l-1}$，那么就得在统计完的时候情况map。
33. cese1621 树状数组优化约瑟夫环。
34. 编辑距离：f[i][j]，如果i和j的差值很小，此时就可以把第二维变成k，也就是f[i][j-k+1]
35. 遇到一个数据范围很小的，就得琢磨如何从这个地方突破。
36. 如果遇到说什么 C(n,k) 的总和小于等于10^6，此时我们就可以去考虑暴力，因为它说明n小的时候k不大，n大的时候k不小。
37. 有的时候固定一个端点可以把它排序看看，然后另一个端点可以贪心了。（相关题目：cses2168）
38. 常见思维：正难则反，固定一端点（排序）
39. 区间问题：差分（类似cses1164的那种，广义差分）；排序（固定左端点然后去分析它的性质的）；区间合并（板子）；基本贪心策略。
40. 以后二分找数一般用<= 的那种形式，要不然很容易产生越界问题。
41. 栈可以维护最近的比它大的/小的位置。
42. 尺取法有两种情况，一种是固定l去搞r，这种适用于某某最少的情况。另一种就是固定r去搞l，这种适用于某某最多的情况。
43. 对于给定多个区间问它最多不重叠的个数这种题都是按结束时间排序的。类似(cses1632的题目)，此时就是要让k个人放在重叠的部分，此时就可以用`multiset` 来维护。
44. 如果要算完全背包问题的方案数，那就得具体到每一种情况，此时的状态就不能是背包问题的状态，此时就得是表示 f[i] 表示容量为i的方案数。（具体见cses1635）
45. 如果想到dp的话，不知道怎么转移，可以考虑特殊情形，即n比较小的时候答案的分布是如何的。(类似题目cses2143)
46. dp如果跟多维度有关系的话，可以对dp开结构体，比如cses1653，这道题考的是状态压缩，而且它的状态会受到和的影响，此时就得开结构体。本道题的状态表示是：`f[i]` 如果二进制中有1的话此时表示选这些人上电梯的最优方案。
47. 当看到n比较小的时候，必须考虑状态压缩（位运算），表示选和不选，比如cses2181，n比较小，然后发现1x2的可以通过枚举状态来实现放置。
48. 如果遇到要算贡献法的时候，可以先把那个表列出来（就是二维表），看看横着好找贡献还是竖着好找。(https://www.luogu.com.cn/article/st37hwwc)
49. dijistra可以处理环，但它不能处理负环。
50. 对于CF2077A的构造，要注意发现b的范围比a小，因此我们构造的其中一个值要越大越好。所以根据公式：$a_1=a_2-a_3+a_4...$ 我们可以推出：$a_2=a_1+a_3-a_4...$，这样我们把数组排序，然后把大的数放在 $a_1...$。
51. 对于算区间中的种类数，建议是将左端点和右端点区分开。类似[P2184](https://www.luogu.com.cn/article/e6dz9cr8)
52. 栈可以维护比如我们删除掉ABC这个字符，维护删除后的字符的相对顺序。
53. 拓扑序可以跟最长路结合在一起。
54. 什么时候得考虑到队列：一种顺序要跟最前面的数有关，为了更快访问，就得用队列。
55. 对于一道题目，如果存在绝对值，我们得尝试把他展开。
56. 做大模拟题的时候，我们得注意举几个样例来有计划的写。
57. 对于移动问题，若已知起点和终点，要让它能移动到正确位置上，那么它必须是k的倍数。（遇到这类问题首先看起点和终点的坐标关系，其次再看图上的关系）（例如cf1828B）
58. 以后遇到 ax+by=c的时候，那么x+y 的最大值就是 c/b，最小值就是c/a，然后再通过带入c值来确定具体值。
59. 有的时候从前到后很有问题（尤其是后效性，就是如果我这个修改了后面就会发生根本性改变），此时我们就得从后往前。
60. 以后构造题要大胆的想象。
61. 如果对于一道题没有任何思路，我们可以考虑找规律试试。
62. 题目说能进行任意次操作，说明每个数都可以被操作。
63. 自然数亦或周期性:
```
int calc(int x){
    if(x%4==0)return x;
    if(x%4==1)return 1;
    if(x%4==2)return x+1;
    return 0;
}

```
64. 有的时候题目不好理解或者不好写的情况下，我们可以把题目转化一下，比如cf1506C
65. 如果题目叫我们求某些数或起来要等于自己，那么怎么找呢？我们可以把数全部或上要找的那个数即可。(cf1842B)
66. 比如cf1827A这道题，我们算出来ai>bi的个数，然后要求方案数，也就是这些个数限制的方案数，有个很重要的想法就是把这些个数从小到大排序，然后把 ci-i+1 的数目乘起来。很重要的思想。
67. 遍历树的时候要统计个数，我们最好用数组，然后回溯的时候就b[u]+=b[j]，其中u是根节点，j是子结点。
68. 当我们很难维护一个点的情况下，我们可以考虑维护区间。比如CF1907D
69. 有的时候实在想不到，我们就排序看看，因为排序往往能跟双指针和二分有关，因为有单调性。
70. 如果两个数是有关系的，也就是我选这个另一个数也必须选，此时我们我们可以把它和在一起运算，即可以把它+/-。
71. 当题目说可以任意次操作某个相邻的东西，那么我们就得想到他它可以被推广成操作任意两个的。
72. 区间查询与或都可以用st表。
73. 以后盲猜要浅浅验证一下。
74. 数学公式如果遇到连等号或连小于大于我们可以拆成最小单元来看。这样往往会有意想不到的结果。
75. 比如一个数能被1,2...9 整除，那么它就可以被lcm(1,2...9) 整除，此时它就能被2520整除，所以cf1411B能用加的方式来做。
76. 对于数论题，如果数字最多只有10^18 的情况下，我们往往分析整除这些性质，此时不要想到字符串那边去。
77. x&(-x)：保留二进制下最后出现的1的位置，其余位置置0（即一个数中最大的2的n次幂的因数,x&(x-1)：消除二进制下最后出现1的位置，其余保持不变，也就是判断是不是2的幂次方。
78. 子串问题，cf1416A（很经典）、cf1404A（性质直接用公式来做,因为题目有等式关系）
79. 如果题目出现等式关系的时候，我们可以往等式和推公式的方向去想。
80. 位运算认真分析性质。（cf1775C）
81. 中位数的题目有时候可以用二分来做，只需要满足左边和右边尽可能相等即可。
82. 对于大模拟题目，我们要明确方向，不要一上来就开始写代码。
83. 一个dfs序有cntson[j]!个。
84. 如果我们要防止去重的时候枚举倍数，我们就得考虑除它们的 `gcd`。
85. 欧拉回路度数要是偶数，要求它的路径的话，我们就得每次dfs删一条边。
86. 对于没有修改的操作，我们可以用倍增的方法。
87. 线段树来做既有区间赋为一个固定的数，也有让一个区间增加一个数的操作，此时我们就得开两个标记，然后我们让tag标记优先于jyz标记，这样我们修改的时候就得多一步pushdown，目的是为了确保jyz标记向下传递了(例如cses1735)
88. 以后要双指针的时候，我们得考虑一下双指针是否能行，因为双指针在有abs的时候不怎么好用，此时我们建议用二分。
89. 有的时候维护边的关系的时候我们可以直接枚举每条边分析它的端点，当且仅当题目中存在上面关系比较的时候考虑。（比如cf1548A）
90. 注意dfs序的时候，`dfn[u]+siz[u]-1`，因为siz[u]是包括u这个点的。
91. 树链剖分就是类似lca向上跳到同一个重链。
92. 对于计算树的子树中颜色的个数，我们可以用小的合并大的思路。（cses1139）
93. 特殊的约瑟夫环，当每隔1个人，规律如下：(cses2164)

n 1 2 3 4 5 6

J(n) 1 1 3 1 3 5

可以发现：J(2n)=2J(n)-1,J(2n+1)=2J(n)+1
其中 J(n) 表示最终的赢家。
附加公式：J(n,k)=(J(n-1,k)+k)%n

94. 求 $a^b^c\%1e9+7$,根据欧拉定理：$a^k===a^{k\%\phi(m)}$,质数的$\phi(x)$ 是等于 x-1的。
95. 约数和：(1+p_1+p_1^{a_1}+p_1^{a_2})()(cses1082)
96. 数论分块的k（=n/l）就是d（约数）
97. 因数的乘积是 $n^{d/2}$，其中 $d$ 是约数个数。但如果只给你p和x（因数和指数），那么可以设P_i为质因子的积，那么i-1转移到i需要乘 1,a^1,a^2...a^b，那么此时就是[具体看](https://blog.csdn.net/xhyu61/article/details/126813926)。
98. 莫比乌斯函数可以做到线性的容斥。也就是说 [gcd(i,j)=1]=\sum_{d|gcd(i,j)}^{\mu(d)}
u(n)=1 当n=1；当u(n)=0 n含有平方因子；u(n)=(-1)^k k为n的本质不同质因子个数。\phi(n)=\sum_{d|n}^{d u(n/d)}=> 也就是假如给定查询与16互质数字的个数，\sum_{d|16}^{\mu(d)cnt(d)}。
99. 错位排序：(n-1)(D(n-1)+D(n-2))，其中d[1]=0,d[2]=1
100. 卡特兰数可以解决括号匹配的个数问题，如果没有起始的坐标（没有初始括号），此时我们默认就是从 (0,0) 开始，不越过 y=x 到达 (n,n) 的方法数，但对于cses2187 它给定你初始的括号，此时我们的起点就是从 (a,b) 开始，其中a是初始的左括号数，不越过y=x到达终点 (n/2,n/2)了。所以方案数就是 (n/2,n/2)-(n/2-1,n/2+1)
101. 斐波那契数列性质，当n是偶数，k=n/2，那么F(n)=F(k)*F(k)+F(k-1)*F(k-1)，如果n是奇数,k=n/2,F(n)=F(k)*(F(k-1)+F(k+1))。具体cses1096
102. 矩阵乘法最好把式子列出来，要不然很抽象我靠。
103. 图上问距离你的任务是计算从节点 1 到节点 n 的路径数，要求路径长度恰好为 k，可以用矩阵乘法（cses1723）。为什么能用，因为k比较大，n比较小。
104. cses2420 很好的哈希的线段树。总之就是跟哈希通式联系在一起。
105. vector 中可以写 w.end()[-2],指的就是从后往前数第二个位置。
106. 边界的格点数
把每条边当作左开右闭的区间避免重复，一条左开右闭的线段 AB上的格点数为 gcd(Bx−Ax,By−Ay)。
107. 
bitset用处：
    解决汉明距离。（就是快速计算两个字符串不同的元素数量）
    解决树上可达问题。(可以让空间减少32倍)

108. 能够优化bitset速度问题：#pragma GCC target("popcnt")
109. 数学公式最好不要推到不等式去。
110. 区间问题匹配一般都是贪心先想，实在不行的话就用dp。（比如LG-P3661）
111. 如果以后遇到有公式在那里，我们先考虑推公式，比如P5425（非常好的数学题）
112. P3621 很好的一道完全二叉树的题目，遇到这种分类讨论的题目不要害怕，在纸张上写下每一种情况（而且完全二叉树不就是图论么，所以不要担心做不来啊）
113. P2769 每一棵树上都要有至少一只猴子 这就决定了我们的程序循环里主要的部分是枚举树 而不是猴子 注意 是主要的部分！
114. 对于有类似公式的题目，也就是有等价关系的题目，建议列出公式会更好做。
115. 以后遇到数组只能用一次的技能，我们得考虑左边和右边来看（也就是考虑前缀和和后缀和）
116. 二进制能表示任意一个数，也就是对于 1,2,4,8....2^{K-1} 能表示2^{k}-1。
117. 以后遇到下标跟数字有关系的时候，考虑并查集。
118. 如果dp是跟树的层数有关的话，此时就按层数，也就是用两个数组，一个是放某一层的总方案数，一个是放某个点的方案数。比如CF2070D，我如果只用 f[u][0/1]来考虑的话，我感觉初始状态都写不了，所以只能用前面刚刚说到的方法来做。
119. 如果(a+b)能整除b，那么a就能整除b。
120. 完全平方数有奇数个因子。
121. 区间不相交的个数可以用二分做，也就是把左右端点都存下来。
122. CF1535D很好的一道二叉树用线段树的性质来做：[解题](https://www.luogu.com.cn/article/8cit1lza)

## 好题（待写到网站）

arc127a
abc150d
abc168e
abc170e
cf1705C
abc173e
abc131f
abc133f
abc204c-2 bitset优化的
abc217e multiset加优先级
abc225d 链表
abc203e
cf1847c 字典树
cf1927d 很好的构造题，前缀和不同种类的个数来构造
cf1881d 很好的整体取模的题目

## 值得再做的题
cf1876a 队列
cf1849b 队列，要模一下