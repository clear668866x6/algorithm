## 体会

1. 发现 `codeforces` 的 edu 很多跟abc都是板题。
2. `multiset` 是基于红黑树实现的，它的时间复杂度：
```
插入操作：O(log n)
查找操作：O(log n)
删除操作：O(log n)
```
3. multiset 可以加入优先级，即 `multiset<PII>`。
4. multiset 删除最后一个元素必须要 --s.end()，删除第一个元素就不需要了
5. 数位dp：一般的bool有两个，一个是到达边界一个是到达0。然后看情况新增变量。
6. 有自环情况下，拓扑序无法处理，此时要求循环节就必须用暴力的方式。
7. 以后如果简单题想复杂就不要继续往这方面想，想问题得用多个角度来做。
8. 当需要排序的内容与两个变量有关的情况下，我们可以考虑相加（此时也叫做邻项交换法）
9. 如果 $a_i=\max(b_i,b_{i+1})，a_{i-1}=\max(b_{i-1},b_i)$ 的时候，那么 $b_i\le \min(a_i,a_{i-1})$。 
10. 有要求什么约数的时候，埃氏筛的思想很重要，就是把它的倍数都标记了的思想。
11. 很多情况下，如果求双重循环，此时可以考虑把这个数组排序完再算。
12. 如果把一个数分解成 $(r-l+1)(l+r)=n$ 的形式，此时就得考虑枚举因数了。
13. 算排名最好用`upper_bound`，要不然会有问题的。
14. 有时候题目很像差分，但数据规模很大，那么我们可以用 `map` 来维护，或者通过类似：`w[++cnt]={l,1},w[++cnt]={l+r,-1}` 的操作，然后通过画图可以去分析它们的性质（据说可能还会有单调性，比如abc221d）。
15. 有的时候得注意精度啊，服了啊，刚刚没有开 __int128 就爆炸了。
16. 题目长的时候得认真看呐，要不然会出问题啊。
17. 多项式乘法除法可以采用大除法。
多项式大除法：
```
void solve() {
    cin>>n>>m;

    FOR(i,0,n)cin>>a[i];
    FOR(i,0,n+m)cin>>c[i];

    FORD(i,0,m){
        b[i]=c[i+n]/a[n];
        FOR(j,0,n){
            c[i+j]-=b[i]*a[j];
        }
    }

    FOR(i,0,m)cout<<b[i]<<" ";
}
```
18. 有时候数据范围小的可能是贪心呐，不要总是想着dfs。
19. 树上两点必然存在简单路径，因此要求两个点间的路径，直接以一个端点为根节点来做就行。
20. 有的时候二分不行的时候（就是想的很复杂的时候），我们可以考虑一下枚举答案。
21. 当出现两个变量的时候，我们尝试去只枚举一个变量，这样就可以看成一层一层的来了。
22. 当大数的时候要算末尾什么0的个数，本质上就是 $2^x\times 5^y$，如果是阶乘的话，$2$ 的因子最多。因为每连续的偶数就有，因此只需要看5的个数。
23. 注意有的时候bfs和dfs的时间复杂度是 $O(2n)$ 的有的时候。
24. 位运算偶尔可以用到字典树，它可以用来算最大异或和。
25. cses1629 选择不相交的区间问题。
26. 有的时候菊花图很有性质啊。
27. 比如cf1893A这道题，如果题目引进了一个全新的概念，此时我们就得去发现全新的概念的性质：比如这道题是移动发现不动点总是在每次移动的最后一个位置。（刚开始想错了，一直想着它跟下标的关系，然后发现找不出任何有关的性质）。
28. gcd(a,b)=gcd(b-a,b)
29. 对于一个集合，要求最小的某个数不能被表示出来。那么就先排序，然后如果前i-1个数能被表示出来，那么它一定能表示出1，所以对于第i个数，肯定能表示出 a_i+1，那么如果我们假设x个数能被表示出来，很容易证明 a_i+x也是能被表示。 那么结论很明显就是 a_i<=x
30. 树状数组优化的最长上升子序列问题的query(w[i]-1)，这里的-1就是保证它是严格的上升。
31. CF1967A [好的讲解](https://zhuanlan.zhihu.com/p/708160419)
32. 如果要算不重叠的 $s_r=s_{l-1}$，那么就得在统计完的时候情况map。
33. cese1621 树状数组优化约瑟夫环。
34. 编辑距离：f[i][j]，如果i和j的差值很小，此时就可以把第二维变成k，也就是f[i][j-k+1]
35. 遇到一个数据范围很小的，就得琢磨如何从这个地方突破。
36. 如果遇到说什么 C(n,k) 的总和小于等于10^6，此时我们就可以去考虑暴力，因为它说明n小的时候k不大，n大的时候k不小。
37. 有的时候固定一个端点可以把它排序看看，然后另一个端点可以贪心了。（相关题目：cses2168）
38. 常见思维：正难则反，固定一端点（排序）
39. 区间问题：差分（类似cses1164的那种，广义差分）；排序（固定左端点然后去分析它的性质的）；区间合并（板子）；基本贪心策略。
40. 以后二分找数一般用<= 的那种形式，要不然很容易产生越界问题。
41. 栈可以维护最近的比它大的/小的位置。
42. 尺取法有两种情况，一种是固定l去搞r，这种适用于某某最少的情况。另一种就是固定r去搞l，这种适用于某某最多的情况。
43. 对于给定多个区间问它最多不重叠的个数这种题都是按结束时间排序的。类似(cses1632的题目)，此时就是要让k个人放在重叠的部分，此时就可以用`multiset` 来维护。
44. 如果要算完全背包问题的方案数，那就得具体到每一种情况，此时的状态就不能是背包问题的状态，此时就得是表示 f[i] 表示容量为i的方案数。（具体见cses1635）
45. 如果想到dp的话，不知道怎么转移，可以考虑特殊情形，即n比较小的时候答案的分布是如何的。(类似题目cses2143)

## 好题（待写到网站）

arc127a
abc150d
abc168e
abc170e
cf1705C
abc173e
abc131f
abc133f
abc204c-2 bitset优化的
abc217e multiset加优先级
abc225d 链表
abc203e
cf1847c 字典树