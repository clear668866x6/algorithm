## 体会

1. 发现 `codeforces` 的 edu 很多跟abc都是板题。
2. `multiset` 是基于红黑树实现的，它的时间复杂度：
```
插入操作：O(log n)
查找操作：O(log n)
删除操作：O(log n)
```
3. multiset 可以加入优先级，即 `multiset<PII>`。
4. multiset 删除最后一个元素必须要 --s.end()，删除第一个元素就不需要了
5. 数位dp：一般的bool有两个，一个是到达边界一个是到达0。然后看情况新增变量。
6. 有自环情况下，拓扑序无法处理，此时要求循环节就必须用暴力的方式。
7. 以后如果简单题想复杂就不要继续往这方面想，想问题得用多个角度来做。
8. 当需要排序的内容与两个变量有关的情况下，我们可以考虑相加（此时也叫做邻项交换法）
9. 如果 $a_i=\max(b_i,b_{i+1})，a_{i-1}=\max(b_{i-1},b_i)$ 的时候，那么 $b_i\le \min(a_i,a_{i-1})$。 
10. 有要求什么约数的时候，埃氏筛的思想很重要，就是把它的倍数都标记了的思想。
11. 很多情况下，如果求双重循环，此时可以考虑把这个数组排序完再算。
12. 如果把一个数分解成 $(r-l+1)(l+r)=n$ 的形式，此时就得考虑枚举因数了。
13. 算排名最好用`upper_bound`，要不然会有问题的。
14. 有时候题目很像差分，但数据规模很大，那么我们可以用 `map` 来维护，或者通过类似：`w[++cnt]={l,1},w[++cnt]={l+r,-1}` 的操作，然后通过画图可以去分析它们的性质（据说可能还会有单调性，比如abc221d）。
15. 有的时候得注意精度啊，服了啊，刚刚没有开 __int128 就爆炸了。
16. 题目长的时候得认真看呐，要不然会出问题啊。
17. 多项式乘法除法可以采用大除法。
多项式大除法：
```
void solve() {
    cin>>n>>m;

    FOR(i,0,n)cin>>a[i];
    FOR(i,0,n+m)cin>>c[i];

    FORD(i,0,m){
        b[i]=c[i+n]/a[n];
        FOR(j,0,n){
            c[i+j]-=b[i]*a[j];
        }
    }

    FOR(i,0,m)cout<<b[i]<<" ";
}
```
18. 有时候数据范围小的可能是贪心呐，不要总是想着dfs。
19. 树上两点必然存在简单路径，因此要求两个点间的路径，直接以一个端点为根节点来做就行。
20. 有的时候二分不行的时候（就是想的很复杂的时候），我们可以考虑一下枚举答案。
21. 当出现两个变量的时候，我们尝试去只枚举一个变量，这样就可以看成一层一层的来了。
22. 当大数的时候要算末尾什么0的个数，本质上就是 $2^x\times 5^y$，如果是阶乘的话，$2$ 的因子最多。因为每连续的偶数就有，因此只需要看5的个数。
23. 注意有的时候bfs和dfs的时间复杂度是 $O(2n)$ 的有的时候。
24. 位运算偶尔可以用到字典树，它可以用来算最大异或和。
25. cses1629 选择不相交的区间问题。
26. 有的时候菊花图很有性质啊。
27. 比如cf1893A这道题，如果题目引进了一个全新的概念，此时我们就得去发现全新的概念的性质：比如这道题是移动发现不动点总是在每次移动的最后一个位置。（刚开始想错了，一直想着它跟下标的关系，然后发现找不出任何有关的性质）。
28. gcd(a,b)=gcd(b-a,b)
29. 对于一个集合，要求最小的某个数不能被表示出来。那么就先排序，然后如果前i-1个数能被表示出来，那么它一定能表示出1，所以对于第i个数，肯定能表示出 a_i+1，那么如果我们假设x个数能被表示出来，很容易证明 a_i+x也是能被表示。 那么结论很明显就是 a_i<=x
30. 树状数组优化的最长上升子序列问题的query(w[i]-1)，这里的-1就是保证它是严格的上升。
31. CF1967A [好的讲解](https://zhuanlan.zhihu.com/p/708160419)
32. 如果要算不重叠的 $s_r=s_{l-1}$，那么就得在统计完的时候情况map。
33. cese1621 树状数组优化约瑟夫环。
34. 编辑距离：f[i][j]，如果i和j的差值很小，此时就可以把第二维变成k，也就是f[i][j-k+1]
35. 遇到一个数据范围很小的，就得琢磨如何从这个地方突破。
36. 如果遇到说什么 C(n,k) 的总和小于等于10^6，此时我们就可以去考虑暴力，因为它说明n小的时候k不大，n大的时候k不小。
37. 有的时候固定一个端点可以把它排序看看，然后另一个端点可以贪心了。（相关题目：cses2168）
38. 常见思维：正难则反，固定一端点（排序）
39. 区间问题：差分（类似cses1164的那种，广义差分）；排序（固定左端点然后去分析它的性质的）；区间合并（板子）；基本贪心策略。
40. 以后二分找数一般用<= 的那种形式，要不然很容易产生越界问题。
41. 栈可以维护最近的比它大的/小的位置。
42. 尺取法有两种情况，一种是固定l去搞r，这种适用于某某最少的情况。另一种就是固定r去搞l，这种适用于某某最多的情况。
43. 对于给定多个区间问它最多不重叠的个数这种题都是按结束时间排序的。类似(cses1632的题目)，此时就是要让k个人放在重叠的部分，此时就可以用`multiset` 来维护。
44. 如果要算完全背包问题的方案数，那就得具体到每一种情况，此时的状态就不能是背包问题的状态，此时就得是表示 f[i] 表示容量为i的方案数。（具体见cses1635）
45. 如果想到dp的话，不知道怎么转移，可以考虑特殊情形，即n比较小的时候答案的分布是如何的。(类似题目cses2143)
46. dp如果跟多维度有关系的话，可以对dp开结构体，比如cses1653，这道题考的是状态压缩，而且它的状态会受到和的影响，此时就得开结构体。本道题的状态表示是：`f[i]` 如果二进制中有1的话此时表示选这些人上电梯的最优方案。
47. 当看到n比较小的时候，必须考虑状态压缩（位运算），表示选和不选，比如cses2181，n比较小，然后发现1x2的可以通过枚举状态来实现放置。
48. 如果遇到要算贡献法的时候，可以先把那个表列出来（就是二维表），看看横着好找贡献还是竖着好找。(https://www.luogu.com.cn/article/st37hwwc)
49. dijistra可以处理环，但它不能处理负环。
50. 对于CF2077A的构造，要注意发现b的范围比a小，因此我们构造的其中一个值要越大越好。所以根据公式：$a_1=a_2-a_3+a_4...$ 我们可以推出：$a_2=a_1+a_3-a_4...$，这样我们把数组排序，然后把大的数放在 $a_1...$。
51. 对于算区间中的种类数，建议是将左端点和右端点区分开。类似[P2184](https://www.luogu.com.cn/article/e6dz9cr8)
52. 栈可以维护比如我们删除掉ABC这个字符，维护删除后的字符的相对顺序。
53. 拓扑序可以跟最长路结合在一起。
54. 什么时候得考虑到队列：一种顺序要跟最前面的数有关，为了更快访问，就得用队列。
55. 对于一道题目，如果存在绝对值，我们得尝试把他展开。
56. 做大模拟题的时候，我们得注意举几个样例来有计划的写。
57. 对于移动问题，若已知起点和终点，要让它能移动到正确位置上，那么它必须是k的倍数。（遇到这类问题首先看起点和终点的坐标关系，其次再看图上的关系）（例如cf1828B）
58. 以后遇到 ax+by=c的时候，那么x+y 的最大值就是 c/b，最小值就是c/a，然后再通过带入c值来确定具体值。
59. 有的时候从前到后很有问题（尤其是后效性，就是如果我这个修改了后面就会发生根本性改变），此时我们就得从后往前。
60. 以后构造题要大胆的想象。
61. 如果对于一道题没有任何思路，我们可以考虑找规律试试。
62. 题目说能进行任意次操作，说明每个数都可以被操作。
63. 自然数亦或周期性:
```
int calc(int x){
    if(x%4==0)return x;
    if(x%4==1)return 1;
    if(x%4==2)return x+1;
    return 0;
}

```
64. 有的时候题目不好理解或者不好写的情况下，我们可以把题目转化一下，比如cf1506C
65. 如果题目叫我们求某些数或起来要等于自己，那么怎么找呢？我们可以把数全部或上要找的那个数即可。(cf1842B)
66. 比如cf1827A这道题，我们算出来ai>bi的个数，然后要求方案数，也就是这些个数限制的方案数，有个很重要的想法就是把这些个数从小到大排序，然后把 ci-i+1 的数目乘起来。很重要的思想。
67. 遍历树的时候要统计个数，我们最好用数组，然后回溯的时候就b[u]+=b[j]，其中u是根节点，j是子结点。
68. 当我们很难维护一个点的情况下，我们可以考虑维护区间。比如CF1907D
69. 有的时候实在想不到，我们就排序看看，因为排序往往能跟双指针和二分有关，因为有单调性。
70. 如果两个数是有关系的，也就是我选这个另一个数也必须选，此时我们我们可以把它和在一起运算，即可以把它+/-。
71. 当题目说可以任意次操作某个相邻的东西，那么我们就得想到他它可以被推广成操作任意两个的。
72. 区间查询与或都可以用st表。
73. 以后盲猜要浅浅验证一下。
74. 数学公式如果遇到连等号或连小于大于我们可以拆成最小单元来看。这样往往会有意想不到的结果。
75. 比如一个数能被1,2...9 整除，那么它就可以被lcm(1,2...9) 整除，此时它就能被2520整除，所以cf1411B能用加的方式来做。
76. 对于数论题，如果数字最多只有10^18 的情况下，我们往往分析整除这些性质，此时不要想到字符串那边去。
77. x&(-x)：保留二进制下最后出现的1的位置，其余位置置0（即一个数中最大的2的n次幂的因数,x&(x-1)：消除二进制下最后出现1的位置，其余保持不变，也就是判断是不是2的幂次方。
78. 子串问题，cf1416A（很经典）、cf1404A（性质直接用公式来做,因为题目有等式关系）
79. 如果题目出现等式关系的时候，我们可以往等式和推公式的方向去想。
80. 位运算认真分析性质。（cf1775C）

## 好题（待写到网站）

arc127a
abc150d
abc168e
abc170e
cf1705C
abc173e
abc131f
abc133f
abc204c-2 bitset优化的
abc217e multiset加优先级
abc225d 链表
abc203e
cf1847c 字典树
cf1927d 很好的构造题，前缀和不同种类的个数来构造
cf1881d 很好的整体取模的题目

## 值得再做的题
cf1876a 队列
cf1849b 队列，要模一下